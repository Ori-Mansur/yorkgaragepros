import { db, storage } from './firebase'; // Adjust this path to your firebase config
import { collection, addDoc, serverTimestamp, query, where, orderBy, limit, getDocs } from 'firebase/firestore';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';

/**
 * Saves document data to Firestore and uploads the generated PDF to Storage
 * @param {Object} formData - The raw data from your Vue form
 * @param {Blob} pdfBlob - The PDF file generated by jsPDF
 * @param {String} fileName - Desired name for the file
 */
export const saveDocToCloud = async (formData, pdfBlob, fileName) => {
    try {
        // 1. Upload PDF to Firebase Storage
        // We add a timestamp to the filename to prevent overwriting files with the same name
        const storagePath = `documents/${formData.type}/${fileName}_${Date.now()}.pdf`;
        const storageRef = ref(storage, storagePath);

        const uploadResult = await uploadBytes(storageRef, pdfBlob);
        const downloadURL = await getDownloadURL(uploadResult.ref);

        // 2. Save Record to Firestore
        const docRef = await addDoc(collection(db, "documents"), {
            // Document Tracking
            type: formData.type, // QUOTE, INVOICE, or RECEIPT [cite: 3]
            number: formData.number, // 
            issueDate: formData.issueDate, // 
            dueDate: formData.dueDate, // 

            // Client Details
            clientName: formData.clientName, // [cite: 5]
            address: formData.address, // [cite: 6]
            email: formData.email, // [cite: 7]
            phone: formData.phone,

            // Financials
            items: formData.items, // [cite: 8]
            promoLabel: formData.promoLabel, //[cite: 11]
            discountValue: formData.discountValue, // [cite: 11]

            // File Reference
            pdfUrl: downloadURL,
            storagePath: storagePath,

            // System fields
            createdAt: serverTimestamp(),
            userTimeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            searchName: formData.clientName.toLowerCase() // Useful for searching later
        });

        return downloadURL;
    } catch (error) {
        console.error("Error in dbDocService:", error);
        throw error;
    }
};

/**
 * Gets the next available document number and increments the counter
 * @param {String} type - 'QUOTE', 'INVOICE', or 'RECEIPT'
 */


export const getNextDocNumber = async (type) => {
    const prefixes = {
        'QUOTE': 'QTE',
        'INVOICE': 'INV',
        'RECEIPT': 'RCP'
    };
    const prefix = prefixes[type] || 'DOC';

    try {
        // Query only for the most recent document of this type
        const q = query(
            collection(db, "documents"),
            where("type", "==", type),
            orderBy("createdAt", "desc"),
            limit(1)
        );

        const querySnapshot = await getDocs(q);

        if (querySnapshot.empty) {
            return `${prefix}-1000`;
        }

        // We receive the whole doc, but we ONLY access the 'number' field
        const latestDocData = querySnapshot.docs[0].data();
        const lastNumberStr = latestDocData.number; // e.g., "QTE-1055"

        // Extract and increment
        const lastNum = parseInt(lastNumberStr.split('-')[1]);
        const nextNum = isNaN(lastNum) ? 1000 : lastNum + 1;

        return `${prefix}-${nextNum}`;

    } catch (e) {
        console.error("Error calculating next number:", e);
        return `${prefix}-${Math.floor(Math.random() * 9000) + 1000}`;
    }
};